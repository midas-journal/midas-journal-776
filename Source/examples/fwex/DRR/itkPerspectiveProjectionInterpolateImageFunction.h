
#ifndef __ITKPERSPECTIVEPROJECTIONINTERPOLATEIMAGEFUNCTION_H
#define __ITKPERSPECTIVEPROJECTIONINTERPOLATEIMAGEFUNCTION_H

#include "itkInterpolateImageFunction.h"
#include "itkNearestNeighborInterpolateImageFunction.h"
#include "itkPerspectiveProjectionImageFilter.h"
#include "itkUpdateCommand.h"

namespace itk
{

/** \class PerspectiveProjectionInterpolateImageFunction
 * \brief Interpolate a perspectively projected image (digitally reconstructed
 * radiograph, DRR).
 * \author Markus Neuner, neuner.markus e_T gmx.net
 *
 * This class is an adapter (wrapper) to use the implemented DRR generation
 * filters with the ITK registration framework.
 * It is responsible to generate or update a DRR through an implementation of
 * PerspectiveProjectionImageFilter whenever the transform inside the
 * registration framework or the volumetric dataset is changed or modified.
 *
 * The interpolator translates evaluation calls of the metric component and
 * performs interpolation in the generated DRR.
 *
 * It needs to be updated through Update() when parameters of the filter are
 * modified. It is updated automatically if the update command is enabled
 * with SetUpdateActive() and the transform of the filter is modified.
 *
 * \warning The dimension of the input and output image must be three and only
 * scalar voxel/pixel types are supported. It is intended to only be used as
 * interpolator inside the registration framework.
 *
 * \see PerspectiveProjectionImageFilter
 * \see SplatPerspectiveProjectionImageFilter
 * \see RayCastPerspectiveProjectionImageFilter
 *
 * \ingroup ImageFunctions ImageInterpolators
 */
template <class TInputImage, class TCoordRep = double,
  class TCollector = Collector::SumCollector<double> >
class ITK_EXPORT PerspectiveProjectionInterpolateImageFunction :
  public InterpolateImageFunction<TInputImage,TCoordRep>
{

public:
  /** Standard class typedefs. */
  typedef PerspectiveProjectionInterpolateImageFunction   Self;
  typedef InterpolateImageFunction<TInputImage,TCoordRep> Superclass;
  typedef SmartPointer<Self>                              Pointer;
  typedef SmartPointer<const Self>                        ConstPointer;

  /** Some convenient typedefs. */
  itkSuperclassTraitMacro(OutputType);
  itkSuperclassTraitMacro(InputImageType);
  itkSuperclassTraitMacro(RealType);
  itkSuperclassTraitMacro(IndexType);
  itkSuperclassTraitMacro(ContinuousIndexType);
  itkSuperclassTraitMacro(PointType);

  /** Typedef of filter that is used to generate the DRR. */
  typedef PerspectiveProjectionImageFilter<TInputImage, TInputImage,
      TCoordRep, TCollector> PerspectiveProjectionImageFilterType;
  typedef typename PerspectiveProjectionImageFilterType::Pointer
      PerspectiveProjectionImageFilterTypePointer;
  typedef typename PerspectiveProjectionImageFilterType::ConstPointer
      PerspectiveProjectionImageFilterTypeConstPointer;

  /** Typedef for pointer to output of the filter (generated DRR). */
  typedef typename PerspectiveProjectionImageFilterType::OutputImageType 
      ProjectionImageType;
  typedef typename PerspectiveProjectionImageFilterType::OutputImageConstPointer
      ProjectionImageTypeConstPointer;

  /** Typedef of interpolator that is used to interpolate values in the
   * generated DRR.
   */
  typedef InterpolateImageFunction<ProjectionImageType, TCoordRep> ProjectionInterpolatorType;
  typedef typename ProjectionInterpolatorType::Pointer       ProjectionInterpolatorTypePointer;
  typedef typename ProjectionInterpolatorType::ConstPointer  ProjectionInterpolatorTypeConstPointer;

  /**
   * Typedef of an optional intermediate image-to-image filter which is
   * updated right after updating the internal perspective projection.
   */
  typedef ImageToImageFilter<
    typename PerspectiveProjectionImageFilterType::OutputImageType,
    typename PerspectiveProjectionImageFilterType::OutputImageType>
    IntermediateFilterType;
  typedef typename IntermediateFilterType::Pointer IntermediateFilterPointer;

  /** Method for creation through the object factory. */
  itkNewMacro(Self);

  /** Run-time type information (and related methods). */
  itkTypeMacro(PerspectiveProjectionInterpolateImageFunction, InterpolateImageFunction);

  /** Updates the DRR that is generated by set PerspectiveProjectionImageFilter.
   * It needs to be called when parameters of the filter are modified.
   * Is called automatically if the update command is enabled and the transform
   * of the filter is modified.
   * \see SetUpdateActive()
   */
  virtual void Update();

  /** Set the filter that produces a perspectively projected image (DRR) of an
   * input image (volume). This can be any subclass of itk::PerspectiveProjectionImageFilter.
   * Calls Update() after it is set.
   * NOTE: A filter must set!
   * \see PerspectiveProjectionImageFilter
   * \see Update()
   */
  virtual void SetPerspectiveProjectionImageFilter (PerspectiveProjectionImageFilterType*);

  /** Get the set filter that produces a perspectively projected image (DRR) of
   * an input image (volume).
   * \see SetPerspectiveProjectionImageFilter()
   */
  itkGetObjectMacro(PerspectiveProjectionImageFilter, PerspectiveProjectionImageFilterType);

  /** \copydoc SetPerspectiveProjectionImageFilter(PerspectiveProjectionImageFilterType) */
  itkGetConstObjectMacro(PerspectiveProjectionImageFilter, PerspectiveProjectionImageFilterType);

  /** Set the interpolator that is used to interpolate values in the generated
   * DRR. If the fixed image and the DRR have the same size, spacing and origin
   * a nearest neighbour interpolation should be used, because the pixel
   * positions match.
   * The default is itk::NearestNeighbourInterpolateImageFunction.
   */
  itkSetObjectMacro(ProjectionInterpolator, ProjectionInterpolatorType);

  /** Get a pointer to the interpolator function. */
  itkGetConstObjectMacro(ProjectionInterpolator, ProjectionInterpolatorType);

  /** Set if the automatic update is active or not. If enabled the interpolator
   * is updated every time the transform of the DRR generation filter is
   * modified.
   * \see UpdateCommand
   * \see Update()
   */
  virtual void SetUpdateActive(bool);

  /** Get if the automatic update is active or not.  */
  virtual bool GetUpdateActive(void) const;

  /** Set the input image. This is overridden because the input of the DRR
   * generation filter must be set too.
   * \see ImageFunction::SetInputImage()
   */
  virtual void SetInputImage(const InputImageType * ptr);

  /** Evaluate an intensity value at a specified position in the generated DRR.
   * NOTE: The point that should be evaluated must be transformed with the
   * inverse transformation of the set DRR generation filter.
   * This is needed because the metric of the registration framework maps the
   * pixel positions of the fixed image into the moving image space with the
   * same transformation that is used to to transform and position the volume
   * in space. This is a problem in 2D to 3D registration because the 3D
   * transform maps the 2D fixed image anywhere into the moving image space,
   * but the point should lie inside the DRR. It is required to reverse this
   * mapping with the inverse transformation. Then the fixed image is at the
   * same position as the DRR and interpolation can be performed inside the DRR.
   * If the fixed image and the DRR have the same size, spacing and origin a
   * nearest neighbour interpolation should be used, because the pixel
   * positions match. This means that the position, size and spacing of the
   * DRR does not change during the registration process.
   *
   * No bounds checking is done. The point is assumed to lie within the image buffer.
   * IsInsideBuffer() can be used to check bounds before calling this method.
   *
   * \param point Position to interpolate intensity.
   * \return      Interpolated image intensity at specified \a point position in
   *              the DRR.
   */
  virtual OutputType Evaluate(const PointType& point) const;

  /** \see Evaluate(PointType&) */
  virtual OutputType EvaluateAtContinuousIndex(const ContinuousIndexType &) const;

  /** \see Evaluate(PointType&) */
  virtual OutputType EvaluateAtIndex(const IndexType & index) const;

  /** Check if a point, continuous index or index is inside the image buffer.
   * This is overridden since the point needs to be transformed by the inverse
   * transformation of the DRR generation filter. If an index or continuous
   * index is queried it must be transformed into a point first, because the
   * index belongs to the moving image and not the DRR.
  * \warning For efficiency, no validity checking of the input image is done.
  * \see ImageFunction::IsInsideBuffer()
  */
  virtual bool IsInsideBuffer(const PointType &) const;

  /** \see IsInsideBuffer(PointType&) */
  virtual bool IsInsideBuffer(const IndexType &) const;

  /** \see IsInsideBuffer(PointType&) */
  virtual bool IsInsideBuffer(const ContinuousIndexType &) const;

  /** Return this objects modified time based on the components.
   * This is overridden since the time when the object was last modified must
   * consider the stored filter that generates the DRR and the set interpolation.
   * \see Object::GetMTime()
   */
  unsigned long GetMTime(void) const;
  
  /** Get constant pointer of current projected image. **/
  virtual ProjectionImageTypeConstPointer GetProjectedImage()
  {
    return m_ProjectedImage;
  }
  
  /** Get/set automatic min/max output intensity search mode. **/
  itkGetMacro(FindMinMaxIntensityMode, bool);
  itkSetMacro(FindMinMaxIntensityMode, bool);

  /** Get min/max intensity values of projection image. **/
  itkGetConstMacro(MinIntensity,
    typename PerspectiveProjectionImageFilterType::OutputPixelType);
  itkGetConstMacro(MaxIntensity,
    typename PerspectiveProjectionImageFilterType::OutputPixelType);

  /**
   * Get/set the optional intermediate filter which is updated right after
   * the update of the internal perspective projection. Has no effect if NULL!
   */
  itkGetObjectMacro(IntermediateFilter, IntermediateFilterType);
  itkSetObjectMacro(IntermediateFilter, IntermediateFilterType);


protected:
  /**
   * Automatically search for min/max output intensities in projection image
   * ON/OFF.
   */
  bool m_FindMinMaxIntensityMode;
  /** Min/max output projection image intensities. **/
  typename PerspectiveProjectionImageFilterType::OutputPixelType m_MinIntensity;
  typename PerspectiveProjectionImageFilterType::OutputPixelType m_MaxIntensity;
  /**
   * An optional intermediate filter which is updated right after the update
   * of the internal perspective projection. Has no effect if NULL!
   */
  IntermediateFilterPointer m_IntermediateFilter;

  /** Constructor: Initialise new instance. */
  PerspectiveProjectionInterpolateImageFunction();
  ~PerspectiveProjectionInterpolateImageFunction(){};

  /** Print out a description of self. */
  void PrintSelf(std::ostream& os, Indent indent) const;

  /** Typedef of inverse transform of transform used in the set DRR generation
   * filter.
   */
  typedef typename PerspectiveProjectionImageFilterType::TransformType InverseTransformType;
  typedef typename InverseTransformType::Pointer InverseTransformTypePointer;

  /** Typedef of observer for automatic update. */
  typedef UpdateCommand<PerspectiveProjectionInterpolateImageFunction
      <TInputImage, TCoordRep, TCollector> > UpdateCommandType;
  typedef typename UpdateCommandType::Pointer UpdateCommandTypePointer;

private:
  PerspectiveProjectionInterpolateImageFunction(const Self&); //purposely not implemented
  void operator=(const Self&); //purposely not implemented

  /** Filter that produces a perspectively projected image (DRR) of an input
   * image (volume).
   */
  PerspectiveProjectionImageFilterTypePointer m_PerspectiveProjectionImageFilter;

  /** Pointer to projected image (DRR). */
  ProjectionImageTypeConstPointer m_ProjectedImage;

  /** Interpolator used to interpolate in the DRR. */
  ProjectionInterpolatorTypePointer m_ProjectionInterpolator;

  /** Inverse transform of transform used in the set DRR generation filter. */
  InverseTransformTypePointer m_InverseTransform;

  /** Command that updates the DRR when the transform is modified. */
  UpdateCommandTypePointer m_UpdateCommand;

  /** Tag of the UpdateCommand. Is used to remove the event. */
  unsigned long m_UpdateCommandTag;
};

} // end namespace itk

#ifndef ITK_MANUAL_INSTANTIATION
# include "itkPerspectiveProjectionInterpolateImageFunction.txx"
#endif

#endif
